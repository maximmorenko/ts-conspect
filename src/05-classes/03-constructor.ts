// есть разные сценарии работы со свойствами класса

export class Vehicle {
    // если есть родительский конструктор, то он будет ждать от детей значения, которые передеются в super()
    constructor(private createAt: Date) {}
    // так как свойство приватное, то использовать его можно только в пределах класса
    private log(speed: number): void {
        console.log('Vehicle has changed speed to', speed, this.createAt);
    }
}
// сценарий 1
// раньше было так:
class Car extends Vehicle {
    // свойства требуют инициализации, для этого будем использовать конструктор
    // также для этого можно задать значение по умосчанию, тогда конструктор не нужен
    // или можно поставить знак восклицания color!, что тоже проинициализирует свойство
    // все поля могут иметь модификаторы доступа
    color: string;
    maxSpeed: number;

    constructor (color: string, maxSpeed: number) {
        // конструктор ждет значения из инстанса
        // если есть наследование мы обязаны вызвать супер
        super(new Date());
        this.color = color;
        this.maxSpeed = maxSpeed;
    }
}

// инстанс
const car1 = new Car('red', 23); // передаем параметры в конструктор

// сценарий 2
// TS позволяет не инициализировать в конструкторе свойства
// для этого нужно в параметрах указать модификатор доступа public
class Car2 extends Vehicle {
    // свойства объявлять ненужно, мы их объявляем и инициализируем в параметрах конструктора
    constructor (public readonly color: string, public maxSpeed: number) {
        // свойства могут содержать лубой модификатор доступа а также readonly, который пишется после мод. доступа
        super(new Date());
    }
}

// инстанс2
const car2 = new Car2('blue', 34); // передаем параметры в конструктор
