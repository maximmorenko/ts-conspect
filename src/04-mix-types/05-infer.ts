// оператор infer


function formPair(pair: [string, string]) {
    // на входе ждем пару с типом кортеж
    // делаем деструктуризацию параметров
    const [key, value] = pair;

    // возвращаем объект с динамическим ключем
    return {
        [key]: value
    }
}

// создадим пару и передадим ее в как аргумент
// const myPair = ['myKey', 'myValue']; // получим вот такой тип string[], а нужен кортеж [string, string]
//formPair(myPair) // вроде все правильно, но получим ошибку,TS не верит что это кортеж из строк 
// можно обмануть TS и аргументу указать нужный тип, так сработает, но это неверный путь
// formPair(myPair as [string, string])

// для етого есть специальный оператор infer, который позволяет вывести нужный тип

// на входе имеем функцию <T> и мы хотим вытащить из этой функции значение первого аргумента
// функция T на вхоже ждет тип функции (получим через typeof)
// теперь сделаем проверку что T является следующей структурой (функция у которой обязательно есть первый параметр с определенным типом)
// если он есть этот параметр то возвращаем его тип, если нет - то неве (ничего)
// здесь мы и используем infer, он определяет тип параметра
type FirstArg<T> = T extends (first: infer First, ...args: any[]) => any ? First : never

const myPair: FirstArg<typeof formPair> = ['myKey', 'myValue']; //теперь тип - [string, string], кортеж, тот что нужен

formPair(myPair) // теперь все ок, можно передавать любую структуру



// пример 2 классы

// также указываем что тип должен екстендиться от ньюэлбл структуры в которой также есть первый обязательный аргумент и возможно другие
// также определяем тип первого параметра через infer и возвращаем его тип, либо ничего (never)
type ConstructorFirstArg<T> = T extends { new(arg: infer First, ...args: any[]): any } ? First : never
// проверим на классе
class Computer {
    constructor(brend: string) {}
}
// укажем бренду тип
let brend: ConstructorFirstArg<typeof Computer> = 'тип бренда';

// пример с датой Date
let dateArg: ConstructorFirstArg<typeof Date> = 23;
