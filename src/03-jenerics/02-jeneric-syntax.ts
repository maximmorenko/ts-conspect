// Синтаксис дженериков

// Array<string> //массив строк. альтернатива string[]
// Promis<number> //промис принимающий число

export type TypeFactory<T> = T; 
// эта запись похожа на функцию-фабрику есть что-то на входе и выходе (Т), 
// этот тип динамический, принимает разные типы
// количество параметров божет быть разное
// входные параметры дженериков принято писать в одну букву, но это не обязательно
// type TypeFactory2<T, J> = T; 
// теперь создадим каокйто тип и передадим его в фабрику
type XType = TypeFactory<string>;
type YType = TypeFactory<number>;
type ZType = TypeFactory<boolean>;


// Пример 1
// напишем функцию, которая будет создавать массив
// можно наисать перегрузку
// мы воспользуемся дженериками
function toArray<T>(...arg: T[]): T[] { 
    //эта запись говорит, что бы мы не передали получим из переданого массив
    return arg;
}

toArray(1, 2, 3);
// так как аргументы примитивы, то явно указвать их тип необязательно
// если сложные типы данных то можно передавать интерфейс обхекта и заявлять какие типы данных хотим получить
toArray<number>(4, 8, 34); // явное указание типа аргументов
toArray('df', 'er');

// после компеляции угловых скобок в JS не будет


// Пример 2
// в этом примере прослеживается кейс для строк, мы его оставим
function head(value: string): string;
// кейс на случай пустого массива в значении value (чтобы кейс не мутирвать случайно, установим readonly)
function head(value: readonly []): undefined;
// и 4 кейса которые перепишем на дженерики 
// function head(value: number[]): number;
// function head(value: string[]): string;
// function head(value: boolean[]): boolean
// function head(value: Date[]): Date;
function head<T>(value: readonly T[]): T; // (чтобы кейс не мутирвать случайно, установим readonly)
// создали фабрику, которая будет принимать любой данные с любым типом и создавать из них массив,
// а навыходе ожидаем одно из этих значений (по условию задачи нам нужно первое)
// если же зайдет массив разношерстный (строки цифры ...) то на выходе тоже получим одно значение с типом юнион
// этаже же функция в виде стрелочной:
// const head1 = <T>(value: T[]): T => value[0];

function head(value: any): any {
    return value[0];
}
head([1, 2, 3])
head(['1', '2', '3'])
head([true, true, false])


// Пример 3

// перепишем интерфейс на дженерики
// interface ModelData {
//     title: string;
//     value: string;
// }

// <T> - вход данных
// Т - выход данных
interface ModelData<T> {
    title: string;
    value: T; // значение может быть любым
}

const obj1: ModelData<number> = {
    // мы должны указать явный параметр которы хотим записать в value (в данном случае <number>)
    title: 'ererer',
    value: 4545,
}
const obj2: ModelData<string> = {
    // мы должны указать явный параметр которы хотим записать в value (в данном случае <srting>)
    title: 'ererer',
    value: 'ggghhh',
}
// переписать значение value на другой тип неполучится, так как тип явно указан
// obj2.value = true; //ошибка, неверный тип
// obj2.value = 'hellow'; //ве ок, тип верный, можно изменить значенипе

// создадим объект у которого тип тотже, но дженерик другой, напр. массив чисел Array<number>
const obj3: ModelData<Array<number>> = {
    title: 'уууууууу',
    value: [],
}
