// защита типов

// есть спецальные функции, которые нужны для того чтобы что-то доказать, проверить что именно во входных параметрах

// пример 1
export type Fish = {swim: () => void};
type Bird = {fly: () => void};

// создадим функцию предикат, в которой будем доказывать что животное это рыба
// Предикат — это функция, которая возвращает true или false в зависимости от переданного значения
function isFish (pet: Fish | Bird): pet is Fish {
    // мы должны вернуть созданное утверждение, которое не равно undefined
    // утверждение может быть любым, мы утверждаем, присваиваем pet какую-то сущность, это может быть что угодно, тип, значени
    // утверждение в данном случае это (pet as Fish).swim где мы говорим используй pet как Fish 
    // и возьми у фиш его, пока единственное поле (метод) swim
    // и это утверждение (поле swim) не должно быть undefined
    return (pet as Fish).swim !== undefined;
    // если будет undefined то получим false, если ок то true
}

// Оператор as позволяет сделать утверждение, что та или иная переменная является конкретным типом.
// Он позволяет делать сужение типа для any и unknown, а также для union типов.

// в зависимотся он типа входящего животного бедет сработывать метод
// нужно определить какое животное на входе
// это определит ранее созданная функция предикат, воспользуемся ей и передадим в нее животное
function move (animal: Fish | Bird) {

    if ( isFish(animal)) {
        return animal.swim();
    } 

    return animal.fly();
}

// пример неверного предиката (проверка на null)
function isNull (val: any): val is null {
    return !val
}
// потому что:
const empty = '';
const zero = 0;
if (isNull(empty)) {
    empty //empty: never мы никогда сюда не попадем
}
if (isNull(zero)) {
    zero //zero: never мы никогда сюда не попадем
}
